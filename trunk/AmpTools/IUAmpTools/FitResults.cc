//******************************************************************************
// This file is part of AmpTools, a package for performing Amplitude Analysis
// 
// Copyright Trustees of Indiana University 2010, all rights reserved
// 
// This software written by Matthew Shepherd, Ryan Mitchell, and 
//                  Hrayr Matevosyan at Indiana University, Bloomington
// 
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions
// are met:
// 1. Redistributions of source code must retain the above copyright
//    notice and author attribution, this list of conditions and the
//    following disclaimer. 
// 2. Redistributions in binary form must reproduce the above copyright
//    notice and author attribution, this list of conditions and the
//    following disclaimer in the documentation and/or other materials
//    provided with the distribution.
// 3. Neither the name of the University nor the names of its contributors
//    may be used to endorse or promote products derived from this software
//    without specific prior written permission.
// 
// Creation of derivative forms of this software for commercial
// utilization may be subject to restriction; written permission may be
// obtained from the Trustees of Indiana University.
// 
// INDIANA UNIVERSITY AND THE AUTHORS MAKE NO REPRESENTATIONS OR WARRANTIES, 
// EXPRESS OR IMPLIED.  By way of example, but not limitation, INDIANA 
// UNIVERSITY MAKES NO REPRESENTATIONS OR WARRANTIES OF MERCANTABILITY OR 
// FITNESS FOR ANY PARTICULAR PURPOSE OR THAT THE USE OF THIS SOFTWARE OR 
// DOCUMENTATION WILL NOT INFRINGE ANY PATENTS, COPYRIGHTS, TRADEMARKS, 
// OR OTHER RIGHTS.  Neither Indiana University nor the authors shall be 
// held liable for any liability with respect to any claim by the user or 
// any other party arising from use of the program.
//******************************************************************************

#include <iostream>

#include "IUAmpTools/FitResults.h"
#include "IUAmpTools/LikelihoodCalculator.h"
#include "IUAmpTools/NormIntInterface.h"
#include "IUAmpTools/ConfigFileParser.h"

FitResults::FitResults( ConfigurationInfo* cfgInfo,
                        vector< AmplitudeManager* > ampManVec,
                        map< string, LikelihoodCalculator* > likCalcMap,
                        map< string, NormIntInterface* > normIntMap,
                        MinuitMinimizationManager* minManager,
                        ParameterManager* parManager) :
m_likelihoodTotal( 0 ),
m_cfgInfo( cfgInfo ),
m_ampManVec( ampManVec ),
m_likCalcMap( likCalcMap ),
m_normIntMap( normIntMap ),
m_minManager( minManager ),
m_parManager( parManager ),
m_createdFromFile( false ){
    
}

FitResults::FitResults( const string& inFile ) : m_createdFromFile( true ) {
  
  loadResults( inFile );
}

FitResults::~FitResults() {
  
  if( m_createdFromFile ) {
   
    for( map< string, NormIntInterface* >::iterator mapItr = m_normIntMap.begin();
         mapItr != m_normIntMap.end();
         ++mapItr ){
    
      delete mapItr->second;
    }
  }
}

void
FitResults::saveResults() {
  
  if( !m_createdFromFile ){
    
    recordAmpSetup();
    recordLikelihood();
    recordParameters();
    recordFitStats();
  }
}

void
FitResults::writeResults( const string& outFile ){
  
  ofstream output( outFile.c_str() );
  
  output.precision( 15 );
  
  output << "*** DO NOT EDIT THIS FILE - IT IS FORMATED FOR INPUT ***" << endl;
  output << "+++ Reactions, Amplitudes, and Scale Parameters +++" << endl;
  output << "  " << m_numReactions << endl;
  for( int i = 0; i < m_numReactions; ++i ){

    output << "  " <<m_reactionNames[i] << "\t" << m_numAmps[i] << endl;
    
    for( int j = 0; j < m_ampNames[i].size(); ++j ) {
      
      output << "  " <<m_ampNames[i][j] << "\t" 
             << m_ampScaleNames[i][j] << "\t"
             << m_ampScaleValues[i][j] << endl;
    }
  }
  
  output << "+++ Likelihood Total and Partial Sums +++" << endl;
  output << "  " <<m_likelihoodTotal << endl;
  for( int i = 0; i < m_numReactions; ++i ){
    
    output << "  " <<m_reactionNames[i] << "\t" 
           << m_likelihoodMap[m_reactionNames[i]] << endl;
  }
  
  output << "+++ Fitter Information +++" << endl;
  output << "  " << "lastMinuitCommand\t" << m_lastCommand << endl;
  output << "  " << "lastMinuitCommandStatus\t" << m_lastCommandStatus << endl;
  output << "  " << "eMatrixStatus\t" << m_eMatrixStatus << endl;
  output << "  " << "minuitPrecision\t" << m_precision << endl;
  output << "  " << "minuitStrategy\t" << m_strategy << endl;
  output << "  " << "estDistToMinimum\t" << m_estDistToMin << endl;
  output << "  " << "bestMinimum\t" << m_bestMin << endl;
  
  output << "+++ Parameter Values and Errors +++" << endl;
  output << "  " << m_parNames.size() << endl;
  for( int i = 0; i < m_parNames.size(); ++i ){
    
    output << "  " <<m_parNames[i] << "\t" << m_parValues[i] << endl;
  }
  
  for( int i = 0; i < m_parNames.size(); ++i ){
    for( int j = 0; j < m_parNames.size(); ++j ){
      
      output << "  " << m_covMatrix[i][j] << "\t";
    }
    
    output << endl;
  }
  
  // here we will use the NormIntInterface rather than replicating the
  // functionality that is already found there

  output << "+++ Normalization Integrals +++" << endl;

  for( int i = 0; i < m_reactionNames.size(); ++i ){
   
    string reac = m_reactionNames[i];
    output << "  " << reac << endl;
    
    if( m_createdFromFile || !m_normIntMap[reac]->hasAccessToMC() ){
      
      m_normIntMap[reac]->exportNormIntCache( output );
    }
    else{
      m_normIntMap[reac]->forceCacheUpdate();
      m_normIntMap[reac]->
          exportNormIntCache( output, 
                              m_ampManVec[i]->ampsAreRenormalized() );
    }
  }
  
  output << "+++ Below these two lines is a config file that is   +++" << endl;
  output << "+++ functionally equivalent to that used in the fit. +++" << endl;
  output << *m_cfgInfo;
  
  output.close();
}

void
FitResults::loadResults( const string& inFile ){
  
  enum { kMaxLine = 256 };
  char line[kMaxLine];
  string tmp;
  
  ifstream input( inFile.c_str() );
  input.getline( line, kMaxLine ); // top message
  input.getline( line, kMaxLine ); // amp manager heading
  
  input >> m_numReactions;
  
  m_reactionNames.resize( m_numReactions );
  m_numAmps.resize( m_numReactions );
  m_ampNames.resize( m_numReactions );
  m_ampScaleNames.resize( m_numReactions );
  m_ampScaleValues.resize( m_numReactions );
  
  for( int i = 0; i < m_numReactions; ++i ){
    
    input >> m_reactionNames[i] >> m_numAmps[i];
    
    m_ampNames[i].resize( m_numAmps[i] );
    m_ampScaleNames[i].resize( m_numAmps[i] );
    m_ampScaleValues[i].resize( m_numAmps[i] );
    
    for( int j = 0; j < m_ampNames[i].size(); ++j ) {
      
      input >> m_ampNames[i][j] 
            >> m_ampScaleNames[i][j]
            >> m_ampScaleValues[i][j];      
    }
  }
  
  // one getline clears the newline waiting in the buffer
  input.getline( line, kMaxLine ); // likelihood heading
  input.getline( line, kMaxLine ); // likelihood heading
  
  input >> m_likelihoodTotal;
  
  double val;
  for( int i = 0; i < m_numReactions; ++i ){
    
    input >> tmp >> val;
    m_likelihoodMap[tmp] = val;
  }
  
  input.getline( line, kMaxLine ); // fit info heading
  input.getline( line, kMaxLine ); // fit info heading

  input >> tmp >> m_lastCommand;
  input >> tmp >> m_lastCommandStatus;
  input >> tmp >> m_eMatrixStatus;
  input >> tmp >> m_precision;
  input >> tmp >> m_strategy;
  input >> tmp >> m_estDistToMin;
  input >> tmp >> m_bestMin;
  
  input.getline( line, kMaxLine ); // parameters heading
  input.getline( line, kMaxLine ); // parameters heading

  int nPar;
  input >> nPar;
  m_parNames.resize( nPar );
  m_parValues.resize( nPar );
  m_covMatrix.resize( nPar );
  
  for( int i = 0; i < m_parNames.size(); ++i ){
    
    input >> m_parNames[i] >> m_parValues[i];
    m_parIndex[m_parNames[i]] = i;
  }
  
  for( int i = 0; i < m_parNames.size(); ++i ){
    
    m_covMatrix[i].resize( nPar );
    for( int j = 0; j < m_parNames.size(); ++j ){
      
      input >> m_covMatrix[i][j];
    }    
  }
    
  // here we will use the NormIntInterface rather than replicating the
  // functionality that is already found there
  
  input.getline( line, kMaxLine ); // norm int heading
  input.getline( line, kMaxLine ); // norm int heading
  
  for( int i = 0; i < m_numReactions; ++i ){
    
    string reac;
    input >> reac;
    m_normIntMap[reac] = new NormIntInterface();
    input >> (*m_normIntMap[reac]);
  }    

  // now read back in the ConfigurationInfo using the ConfigFileParser
  input.getline( line, kMaxLine ); // cfg info heading
  input.getline( line, kMaxLine ); // cfg info heading
  input.getline( line, kMaxLine ); // cfg info heading
  
  ConfigFileParser cfgParser( input );
  m_cfgInfo = cfgParser.getConfigurationInfo();
  
  input.close();
}

void
FitResults::recordAmpSetup(){
  
  m_numReactions = m_ampManVec.size();
  
  m_numAmps.clear();
  m_reactionNames.clear();
  m_ampNames.clear();
  m_ampScaleNames.clear();
  m_ampScaleValues.clear();
  
  for( vector< AmplitudeManager* >::iterator ampMan = m_ampManVec.begin();
       ampMan != m_ampManVec.end();
       ++ampMan ){
  
    m_reactionNames.push_back( (**ampMan).reactionName() );
    
    vector< string > ampNames = (**ampMan).getAmpNames();
    
    m_ampNames.push_back( ampNames );
    m_numAmps.push_back( ampNames.size() );
    
    vector< string > ampScaleNames( 0 );
    vector< double > ampScaleValues( 0 );
    
    for( int i = 0; i < ampNames.size(); ++i ){
      
      ampScaleNames.push_back( (**ampMan).getScale( ampNames[i] ).name() );
      ampScaleValues.push_back( (**ampMan).getScale( ampNames[i] ) );
    }
    
    m_ampScaleNames.push_back( ampScaleNames );
    m_ampScaleValues.push_back( ampScaleValues );
  }
}

void
FitResults::recordLikelihood(){

  m_likelihoodTotal = 0;
  
  for( map< string, LikelihoodCalculator* >::iterator 
           mapItr = m_likCalcMap.begin();
       mapItr != m_likCalcMap.end();
       ++mapItr ){
    
    double thisLikVal = (*(mapItr->second))();
    
    m_likelihoodTotal += thisLikVal;
    m_likelihoodMap[mapItr->first] = thisLikVal;
  }
}

void
FitResults::recordParameters(){
  
  m_parNames = m_parManager->parameterList();
  m_parValues = m_parManager->parameterValues();
  m_covMatrix = m_parManager->covarianceMatrix();

  for( int i = 0; i < m_parNames.size(); ++i ){
    
    m_parIndex[m_parNames[i]] = i;
  }

}

void
FitResults::recordFitStats(){
  
  m_eMatrixStatus = m_minManager->eMatrixStatus();
  m_lastCommandStatus = m_minManager->status();
  m_lastCommand = m_minManager->lastCommand();
  m_precision = m_minManager->precision();
  m_strategy = m_minManager->strategy();
  m_estDistToMin = m_minManager->estDistToMinimum();
  m_bestMin = m_minManager->bestMinimum();
}

